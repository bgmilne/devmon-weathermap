#!/usr/bin/perl
# Network Weathermap for Devmon version 1.1.3 (20081023)
# Derived from:
# Network Wearthermap - version 1.1.1 (20040422)
# http://netmon.grnet.gr/weathermap/
# Panagiotis Christias, <christias@noc.ntua.gr>

# Data structures
# nodes = (
#		omicron => (
#			pos => [xxx,yyy]
#			image => xxx.png,
#			label => "Omicron",
#			interfaces => (
#				gi2/6 => )
#					rates => [55, 65],
#					desc => "foo",
#					status => "green",
#				),
#				gi5/7 => [23, 45, "bar"],
#			),
#		eta => (),
#	);
# links = (
#		omicron-eta => (
#				nodea => omicron,
#				nodeb => eta,
#				inta => Gi2/6,
#				intb => Gi5/4,
#			),

$VERSION = "1.1.3";

use Getopt::Long;
use GD;
use Data::Dumper;

################################################################
#
# Configuration parameters
#
$WGET   = "/usr/local/bin/wget -qO -";
#$HTMLSTYLE = "static";
$HTMLSTYLE = "overlib";
$DEBUG  = 0;
if ($ENV{'DEBUG'}) { $DEBUG=1;}
#$WIDTH  = 880;
$WIDTH  = 750;
#$HEIGHT = 750;
$HEIGHT = 550;
$BWLABELS = "percent";
$REVERSEDIRECTION = 0;
$BB = "/usr/lib64/hobbit/client/bin/bb";
$BBDISP = "localhost";
$BBWEBHOST = "http://localhost";
$BBWEBPAGE = "/usr/lib/hobbit/server/bin/bb-webpage";
$CGIBINURL = "/hobbit-cgi";
$ICONDIR="/etc/hobbit/";
#$BBWEBHOSTURL = "http://localhost/hobbit"
#
################################################################
if ($ENV{'BBHOME'}) {
	$CONFIG = "$ENV{'BBHOME'}/etc/weathermap.conf";
	$BBWEBPAGE = "$ENV{'BBHOME'}/bin/bb-webpage";
} else {
	$CONFIG = "weathermap.conf";
}
if ($ENV{'BBWWW'}) {
	$OUTPUT = "$ENV{'BBWWW'}/weathermap.png";
	$HTMLOUTPUT = "$ENV{BBWWW}/weathermap.html";
} else {
	$OUTPUT = "weathermap.png";
	$HTMLOUTPUT = "";
}

if ($ENV{'BB'}) {
	$BB = $ENV{'BB'};
}
if ($ENV{'BBDISP'}) {
	$BBDISP = $ENV{'BBDISP'};
}
if ($ENV{'BBWEBHOST'}) {
	$BBWEBHOST = $ENV{'BBWEBHOST'};
}
if ($ENV{'CGIBINURL'}) {
	$CGIBINURL = $ENV{'CGIBINURL'};
}

%optctl=();
#GetOptions(\%optctl, "config:s", "output:s", "version", "help", "debug", "") || exit(1);
GetOptions(\%optctl, "image-uri:s", "config:s", "output:s", "version", "help", "debug", "htmloutput:s", "") || exit(1);

if($optctl{"config"}) { $CONFIG = $optctl{"config"} };

if($optctl{"output"}) { $OUTPUT = $optctl{"output"} };

if($optctl{"htmloutput"}) { $HTMLOUTPUT = $optctl{"htmloutput"} };

if($optctl{"version"}) { &version; exit; }

if($optctl{"help"}) { &usage; exit; }

if($optctl{"debug"}) { $DEBUG=1; }

&read_config($CONFIG);
print Dumper(%nodes) if ($DEBUG);

if($background){
	open (PNG,"$background") || die "$background: $!\n";
	$map = newFromPng GD::Image(PNG) || die "newFromPng failed.";
	$white = $map->colorClosest(255,255,255);
	$map->transparent($white);
	close PNG;
} else {
	$map=new GD::Image($WIDTH,$HEIGHT);
	$white = $map->colorAllocate(255,255,255);
        $map->transparent($white);
        $map->interlaced('true');
	$map->saveAlpha(1);
	#$map->alphaBlending(0);
}

&alloc_colors;

print "Opening log files...\n\n" if($DEBUG);

foreach $thisnode (keys %nodes) {
	print "Checking node status for $thisnode\n" if ($DEBUG);
	open(CONN, "$BB $BBDISP \"query $thisnode.conn\" |") or warn "$data: $!\n";
	while (<CONN>) {
		if (/^(\w+) /) {
			$nodes{$thisnode}{'status'} = $1;
			print "Node status: $nodes{$thisnode}{'status'}\n" if ($DEBUG);
		}
	}
	close CONN;
	print "Finding values for $thisnode\n" if ($DEBUG);
	my @interfaces = keys %{$nodes{$thisnode}{'interfaces'}};
		open(DEVMON, "$BB $BBDISP \"hobbitdlog $thisnode.if_load\" |") or warn "$data: $!\n";

	while(<DEVMON>){
		if (/^$thisnode\|if_load\|(\w+)\|/) {
			$nodes{$thisnode}{'color'} = $1;
			if ($nodes{$thisnode}{'status'} eq "red") {
				$nodes{$thisnode}{'color'} = $nodes{$thisnode}{'status'};
			}
			# Dont make the device red for if_load being red
			# we'll reserve that for conn
			if ($1 eq "red") { $nodes{$thisnode}{'color'} = "orange";}
			next;
		}
		elsif (/<tr><td>(\S+) ?([^<]+)?<\/td><td>[^<]+<\/td><td>[^<]+\((\d+\.\d+)\%\)<\/td><td>[^<]+\((\d+\.\d+)\%\)(.+)$/) {
			my $intname = $1;
			my $intdesc = $2;
			my $inrate = $3;
			my $outrate = $4;
			#print "$thisnode interface $intname: desc: $intdesc, in $inrate, out $outrate\n" if ($DEBUG);

		#next if (grep {!/$intname/} @interfaces);
		#print "Matched $intname, storing values\n" if ($DEBUG);
		$nodes{$thisnode}{'interfaces'}{$intname}{'rates'} = [$inrate,$outrate];
		$nodes{$thisnode}{'interfaces'}{$intname}{'desc'} = $intdesc
		#$nodes{$thisnode}{'interfaces'}{'label'} = $intdesc;
		}
	}
	close(DEVMON);

	print "Finding link status for $thisnode\n" if ($DEBUG);
	my @interfaces = keys %{$nodes{$thisnode}{'interfaces'}};
		open(DEVMON, "$BB $BBDISP \"hobbitdlog $thisnode.if_stat\" |") or warn "$data: $!\n";

	while(<DEVMON>){
		if (/<tr><td>(\S+) ?([^<]+)?<\/td><td>(\d+\.\d+)[^<]*<\/td><td>&(\w+) [^<]*.*$/) {
			#my $intname = $1;
			#my $intdesc = $2;
			#my $speed = $3;
			#my $status = $4;
			$nodes{$thisnode}{'interfaces'}{$intname}{'status'} = $4
		#next if (grep {!/$intname/} @interfaces);
		}
	}
	close(DEVMON);

}

print "\nCalculating rates...\n\n" if($DEBUG);
print Dumper(%links) if ($DEBUG);
#print "Just dumped %links\n";
#print Dumper(%nodes) if ($DEBUG);

foreach $link (keys %links) {
	print "Finding rates for $link:\n" if ($DEBUG);

	$node1 = $links{$link}{'nodea'};
	$node2 = $links{$link}{'nodeb'};
	$int1 = $links{$link}{'inta'};
	$int2 = $links{$link}{'intb'};
	print "Link details: $node1 - $int1 to $node2 - $int2\n" if ($DEBUG);

	#@link1 = @{$nodes{$links{$link}{'nodea'}}{$links{$link}{'inta'}}};
	#@link2 = @{$nodes{$links{$link}{'nodeb'}}{$links{$link}{'intb'}}};
	@link1 = @{$nodes{$node1}{'interfaces'}{$int1}{'rates'}};
	@link2 = @{$nodes{$node2}{'interfaces'}{$int2}{'rates'}};
	@posa = @{$nodes{$node1}{'pos'}};
	@posb = @{$nodes{$node2}{'pos'}};
	print "In values: $link1[0] == $link2[1], Out values: $link1[1] == $link2[0]\n" if ($DEBUG);
	$outrate = $link1[1] != "" ? $link1[1] : $link2[0];
	$inrate = $link2[1] != "" ? $link2[1] : $link1[0];

	if($output{$link} != 0 && $outrate == 0) { $outrate=1 }
	if($input{$link} != 0 && $inrate == 0) { $inrate=1 }

	my $incolor = &select_color($inrate);
	if ($nodes{$node1}{'interfaces'}{$int1}{'status'} eq "red") {
		$outcolor = $red;
	}
	my $outcolor = &select_color($outrate);
	if ($nodes{$node2}{'interfaces'}{$int2}{'status'} eq "red") {
		$incolor = $red;
	}

	#print "$target{$link}: outrate=$outrate%, inrate=$inrate%\n" if($DEBUG);
	print "$link from $posa[0],$posa[1] to $posb[0],$posb[1] outrate=$outrate%, inrate=$inrate%\n" if($DEBUG);

	# draw lines...

	$width=7;
	$width=$linkwidth{$link};

	if (defined $links{$link}{'via'}) {
		@middle = @{$links{$link}{'via'}}
	} else {
		@middle[0] = &middle($posa[0],$posb[0]);
		@middle[1] = &middle($posa[1],$posb[1]);
	}

	&draw_arrow(
		$posa[0],
		$posa[1],
		$middle[0],
		$middle[1],
		$width, 1, $outcolor);

	&draw_arrow(
		$posa[0],
		$posa[1],
		$middle[0],
		$middle[1],
		$width, 0, $black,$link,0);

	if($BWLABELS eq "percent")
	{
		$outlabel = $outrate."%";
		$inlabel = $inrate."%";
	}
	else
	{
		$outlabel = format_bytes($output{$link} * 8,1);
		$inlabel = format_bytes($input{$link} * 8,1);
	}


	&label(&middle($posa[0],&middle($posa[0],$posb[0])),
		&middle($posa[1],&middle($posa[1],$posb[1])),
		$outrate . "%", 0,gdSmallFont,"","");


	&draw_arrow(
		$posb[0],
		$posb[1],
		$middle[0],
		$middle[1],
		$width, 1, $incolor);

	&draw_arrow(
		$posb[0],
		$posb[1],
		$middle[0],
		$middle[1],
		$width, 0, $black,$link,1);


	&label(&middle($posb[0],$middle[0]),
		&middle($posb[1],$middle[1]),
		$inrate . "%", 0, gdSmallFont,"","");

}
print "\n" if($DEBUG);

foreach (keys %nodes) {
	if (defined $nodes{$_}{'icon'}) {
		&icon($nodes{$_}{'icon'},@{$nodes{$_}{'pos'}})
	}
	&label($nodes{$_}{'pos'}[0],$nodes{$_}{'pos'}[1],$nodes{$_}{'label'},3,gdTinyFont,$_,$nodes{$_}{'color'});
	#$map->alphaBlending(1);
	#$map->alphaBlending(0);
}

&annotation;
#&timestamp;

# print image...
print "Generating image file $OUTPUT...\n\n" if($DEBUG);
open(PNG,">$OUTPUT")||die("$OUTPUT: $!\n");
binmode(PNG); # for Windows systems
print PNG $map->png;
close PNG;

if($HTMLOUTPUT ne "")
{
	print "Generating HTML file $HTMLOUTPUT...\n\n" if($DEBUG);
	#open(HTML,">$HTMLOUTPUT") ||die("$HTMLOUTPUT: $!\n");
	open(HTML,"|$BBWEBPAGE --color=green > $HTMLOUTPUT") ||die("$HTMLOUTPUT: $!\n");

	#print HTML '<HTML><HEAD><META HTTP-EQUIV="REFRESH" CONTENT="300" /><TITLE>Network Weathermap</TITLE></HEAD><BODY>';

	if($HTMLSTYLE eq "overlib")
	{
		print HTML "<DIV id=\"overDiv\" style=\"position:absolute; visibility:hidden; z-index:1000;\"></DIV>\n";	
		print HTML "<SCRIPT language=\"JavaScript\" src=\"overlib_mini.js\"><!-- overLIB (c) Erik Bosrup --></SCRIPT> \n";
	}

	my ($width,$height) = $map->getBounds();

	$imageuri = $optctl{'image-uri'} || $OUTPUT;

	print HTML sprintf('<CENTER><IMG SRC="%s" WIDTH="%s" HEIGHT="%s" ALIGN=center BORDER=0 USEMAP="#weathermap_imap" /></CENTER>', $imageuri, $width, $height);
	print HTML '<MAP NAME="weathermap_imap">';
	print HTML $allmap;	
	print HTML '</MAP>';

	#print HTML '</BODY></HTML>';

	close(HTML);
}

# hint, resizing the image could make it look better

exit;

sub timestamp
{
	my $string = localtime();
	my ($width,$height) = $map->getBounds();

	my $xpos = $width - (gdSmallFont->width * (length($string) +1 ));

	$map->string(gdSmallFont,
		$xpos, 10,
		$string, $black)
}

# print labels
sub label{
	my($xpos,$ypos,$label,$pad,$font,$nodename,$color)=@_;

	if(!defined($font))
	{
		$font = gdLargeFont;
	}

	my($strwidth)=$font->width*length($label);
	my($strheight)=$font->height;

	my @coords = ($xpos-$strwidth/2-$pad-2, $ypos-$strheight/2-$pad+1,
		$xpos+$strwidth/2+$pad+1, $ypos+$strheight/2+$pad);

	$tile = new GD::Image(1,1);
	#$tilewhite = $tile->colorAllocateAlpha(255,255,255,15);
	$tilecolor = $tile->colorAllocateAlpha(255,255,255,31);
	if ($color eq "purple") {$tilecolor = $tile->colorAllocateAlpha(255,0,255,31);}
	if ($color eq "yellow") {$tilecolor = $tile->colorAllocateAlpha(255,255,0,31);}
	if ($color eq "blue") {$tilecolor = $tile->colorAllocateAlpha(0,0,255,31);}
	if ($color eq "green") {$tilecolor = $tile->colorAllocateAlpha(0,255,0,31);}
	if ($color eq "orange") {$tilecolor = $tile->colorAllocateAlpha(255,127,0,31);}
	if ($color eq "red") {$tilecolor = $tile->colorAllocateAlpha(255,0,0,31);}
	#$tile->transparent($tilewhite);
	$tile->fill(1,1,$tilecolor);
	$map->setTile($tile);

	#$map->filledRectangle(@coords,$white);
	$map->filledRectangle(@coords,gdTiled);
	#$map->rectangle(@coords,$black);
	$map->string($font,
		$xpos-$strwidth/2, $ypos-$strheight/2+1,
		$label, $black);

	# produce some imagemap data if that's required
	if($nodename ne "")
	{
		print "Producing a Rectangle for $nodename\n" if($DEBUG);
		$overlibgraphurl = $BBWEBHOST . $CGIBINURL . "/hobbitgraph.sh?host=" . $nodename . "&service=la.&graph_height=120&graph_width=576&graph=hourly";
		$infourl = $BBWEBHOST . $CGIBINURL . "/bb-hostsvc.sh?HOST=" . $nodename . "&SERVICE=trends";

		my $active_html = make_html($nodename, $overlibgraphurl, $infourl);

		if($active_html ne "")
		{
			my $html = "<AREA SHAPE=\"RECT\" COORDS=\"";
			$html .= join(",",@coords) . "\" ";
			$html .= $active_html;
			$html .= ">\n";
			
			# we put rectangles at the front of the image map, otherwise they'll always lose out
			# to the arrows already there from when the links were drawn
			$allmap = $html.$allmap;
		}
	}
}

sub icon {
	my ($icon,@pos) = @_;
	$iconfile = $ICONDIR . $icon;
	print "Trying to merge in $iconfile\n" if ($DEBUG);
	if ($iconimage = GD::Image->newFromPng($iconfile,1)) {
		$mywhite = $iconimage->colorAllocate(255,255,255);
		$iconimage->transparent($mywhite);
		@bounds = $iconimage->getBounds;
		@location = ($pos[0]-($bounds[0]/2),$pos[1]-($bounds[1]/2));
		#$map->alphaBlending(0);
		$map->copyMerge($iconimage,@location,0,0,@bounds,75);
		#$map->alphaBlending(1);
	}
}


# print annotation
sub annotation{
	my($title)="Traffic load";
        $strwidth=gdLargeFont->width*length($label{$_});
	$strheight=gdLargeFont->height;

#	$t=localtime(time);
	$t=gmtime(time);
	$map->string(gdSmallFont, 0, 785, "Last update on $t UTC", $black);

	#$map->filledRectangle($keyxpos,$keyypos,
	#	$keyxpos+gdLargeFont->width*length($title)+10,
	#	$keyypos+gdLargeFont->height*($scales+1)+10,
	#	$gray);
	#$map->rectangle($keyxpos,$keyypos,
	#	$keyxpos+gdLargeFont->width*length($title)+10,
	#	$keyypos+gdLargeFont->height*($scales+1)+10,
	#	$black);
	$map->string(gdLargeFont,
		$keyxpos+4,
		$keyypos+4,
		"Traffic load",  $white);

	my($i)=1;
	foreach(sort {$scale_low{$a}<=>$scale_low{$b}} keys %scale_low){
		$map->filledRectangle(
			$keyxpos+6,
			$keyypos+gdLargeFont->height*$i+8,
			$keyxpos+6+16,
			$keyypos+gdLargeFont->height*$i+gdLargeFont->height+6,
			$color{$_});
		$map->string(gdLargeFont,
			$keyxpos+6+20,
			$keyypos+gdLargeFont->height*$i+8,
			"$scale_low{$_}-$scale_high{$_}%", $white);
		$i++
	}
}

sub select_color {
	my($rate)=($_[0]>100) ? 100:$_[0];
	if($rate=="0"){return($darkgray)}
	foreach(sort {$scale_high{$a}<=>$scale_high{$b}} keys %scale_high){
		if($scale_low{$_}<=$rate && $rate<=$scale_high{$_}){
			print "Color for $rate is $color{$_}\n" if ($DEBUG);
			return($color{$_});
		}
	}
}

sub alloc_colors {
	$white=$map->colorAllocate(255,255,255);
	$gray=$map->colorAllocate(248,248,248);
	$black=$map->colorAllocate(0,0,0);
	$darkgray=$map->colorAllocate(128,128,128);
	$red=$map->colorAllocate(0,0,0);

	foreach(keys %scale_red){
		$color{$_} = $map->colorAllocate($scale_red{$_},$scale_green{$_},$scale_blue{$_});
	}
}


sub read_config {
my($config)=shift;
my($node,$link);

print "\nReading configuration file...\n\n" if($DEBUG);

$scales=0;
$last_item = "";
open(CONF,$config) or die "$config: $!\n";
while(<CONF>){
	if(/^\s*BACKGROUND\s+(\S+)/i){
		if(-s "$1"){
			$background=$1;
			print "found BACKGROUND: $background\n" if($DEBUG);
		}
	}
	if(/^\s*HTMLSTYLE\s(\S+)/i)
	{
		# 'static' is the default, set at the top 
		if(lc($1) eq "overlib") {$HTMLSTYLE="overlib"; }
		print "found HTMLSTYLE: $HTMLSTYLE\n" if($DEBUG);
	}
	if(/^\s*WIDTH\s+(\d+)/i){
		if("$1" ne ""){
			if($last_item eq "link")
			{
				$linkwidth{$link}=$1;
				print "found WIDTH for link: $linkwidth{$link}\n" if($DEBUG);
			}
			else
			{
				$WIDTH=$1;
				print "found WIDTH: $WIDTH\n" if($DEBUG);
			}
		}
	}
	if(/^\s*HEIGHT\s+(\d+)/i){
		if("$1" ne ""){
			$HEIGHT=$1;
			print "found HEIGHT: $HEIGHT\n" if($DEBUG);
		}
	}
	if(/^\s*NODE\s+(\S+)/i){
		$node=$1;
		$last_item = "node";
		print "found NODE: $node\n" if($DEBUG);
	}
	if(/^\s*POSITION\s+(\d+)\s+(\d+)/i){
		$xpos{$node}=$1;
		$ypos{$node}=$2;
		$nodes{$node}{'pos'} = ([$1,$2]);
		#$nodes{$node}{'ypos'} = $2;
		print "found NODE: $node XPOS: $xpos{$node} YPOS: $xpos{$node}\n" if($DEBUG);
	}
	if(/^\s*LABEL\s+(\S+)/i){
		$label{$node}=$1;
		$nodes{$node}{'label'} = $1;
		print "found NODE: $node LABEL: $label{$node}\n" if($DEBUG);
	}
	if(/^\s*ICON\s+(\S+)/i){
		$nodes{$node}{'icon'} = $1;
		print "found NODE: $node ICON: $nodes{$node}{'icon'}\n" if($DEBUG);
	}

	if(/^\s*LINK\s+(\S+)/i){
		$link=$1;
		$linkwidth{$link}=7; # some defaults
		$last_item = "link";
		print "found LINK: $link\n" if($DEBUG);
	}
	if(/^\s*NODES\s+(\S+)\s+(\S+)/i){
		$nodea=$1;
		$nodeb=$2;
		$links{$link}{'nodea'} = $1;
		$links{$link}{'nodeb'} = $2;
		print "found LINK: $link NODEA: $nodea NODEB: $nodeb\n" if($DEBUG);
	}
	if(/^\s*INTERFACES\s+(\S+)\s+(\S+)/i){
		$links{$link}{'inta'} = $1;
		$links{$link}{'intb'} = $2;
		$nodes{$nodea}{'interfaces'}{$1}=undef;
		$nodes{$nodeb}{'interfaces'}{$2}=undef;
		print "found LINK interfaces: $link $nodea: $1 $nodeb: $2\n" if($DEBUG);
	}
	if(/^\s*VIA\s+(\d+)\s+(\d+)/i){
		$links{$link}{'via'} = ([$1,$2]);
		print "found LINK VIA: $link $2\n" if($DEBUG);
	}

	if(/^\s*TARGET\s+(\S+)/i){
		$target{$link}=$1;
		print "found LINK: $link TARGET: $target{$link}\n" if($DEBUG);
	}
	if(/^\s*BANDWIDTH\s+(\d+)/i){
		$bandwidth{$link}=$1;
		$maxbytes{$link}=$bandwidth{$link}*1024/8;
		print "found LINK: $link BANDWIDTH: $bandwidth{$link}\n" if($DEBUG);
	}
	if(/^\s*KEYPOS\s+(\d+)\s+(\d+)/i){
		$keyxpos=$1;
		$keyypos=$2;
		print "found KEY POSITION: $keyxpos $keyypos\n" if($DEBUG);
	}
	if(/^\s*SCALE\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/i){
		$scale_low{"$1:$2"}=$1;
		$scale_high{"$1:$2"}=$2;
		$scale_red{"$1:$2"}=$3;
		$scale_green{"$1:$2"}=$4;
		$scale_blue{"$1:$2"}=$5;
		$scales++;
		print "found SCALE DATA: $1:$2 $3:$4:$5\n" if($DEBUG);
	}
}
print "\n" if($DEBUG);
}


sub middle{
	return int( $_[0] + ($_[1]-$_[0])/2 )
}

sub dist{
	return int( sqrt( $_[0]*$_[0] + $_[1]*$_[1] ) )
}

sub newx{
	my($a,$b,$x,$y)=@_;
	return int( cos( atan2($y,$x) + atan2($b,$a) ) * sqrt( $x*$x + $y*$y ) );
}

sub newy{
	my($a,$b,$x,$y)=@_;
	return int( sin( atan2($y,$x) + atan2($b,$a) ) * sqrt( $x*$x + $y*$y ) );
}

sub make_html {
	my($caption,$imagelink,$infolink) = @_;

	my $extrahtml = "";

	if($HTMLSTYLE eq 'overlib')
	{
		if($imagelink ne "")
		{
			$extrahtml .= " onmouseover=\"return overlib('<img src=$imagelink>',DELAY,250,CAPTION,'$caption');\" ";
			$extrahtml .= " onmouseout=\"return nd();\" ";	
		}
	}

	if($infolink ne "")
	{
		$extrahtml .= " HREF=\"$infolink\" ";
	}

	return $extrahtml;
}


sub draw_arrow {
	my($x1,$y1,$x2,$y2,$w,$solid,$color,$linkname,$side)=($_[0],$_[1],$_[2],$_[3],$_[4],$_[5],$_[6],$_[7],$_[8]);
	if ($side eq 0 ) {
	        $node = $links{$linkname}{'nodea'};
	        $int = $links{$linkname}{'inta'};
		$desc = $node . ":" . $int . " - " . $nodes{$node1}{'interfaces'}{$int1}{'desc'};
	} elsif ($side eq 1) {
	        $node = $links{$linkname}{'nodeb'};
	        $int = $links{$linkname}{'intb'};
		$desc = $node . ":" . $int . " - " . $nodes{$node2}{'interfaces'}{$int2}{'desc'};
	}
	$int =~ s/\//_/g;
	#$overlibgraphurl = $BBWEBHOST . $CGIBINURL . "/hobbitgraph.sh?host=" . $node . "&service=if_load:" . $int . ".&graph_height=120&graph_width=576&graph=hourly";
	$hosturl = $BBWEBHOST . $CGIBINURL . "/hobbitgraph.sh?host=" . $node . "&service=if_load:" . $int . ".&graph_height=120&graph_width=576";
	#$infourl = $BBWEBHOST . $CGIBINURL . "/bb-hostsvc.sh?HOST=" . $node . "&SERVICE=trends";
	$overlibgraphurl = $hosturl . "&graph=hourly";
	$infourl = $hosturl . "&color=green&action=menu";
	my($arrow)=new GD::Polygon;

	$arrow->addPt(
		$x1 + &newx($x2-$x1, $y2-$y1, 0, $w),
		$y1 + &newy($x2-$x1, $y2-$y1, 0, $w)
		);

	$arrow->addPt(
		$x2 + &newx($x2-$x1, $y2-$y1, -4*$w, $w),
		$y2 + &newy($x2-$x1, $y2-$y1, -4*$w, $w)
		);

	$arrow->addPt(
		$x2 + &newx($x2-$x1, $y2-$y1, -4*$w, 2*$w),
		$y2 + &newy($x2-$x1, $y2-$y1, -4*$w, 2*$w)
		);

	$arrow->addPt( $x2, $y2);

	$arrow->addPt(
		$x2 + &newx($x2-$x1, $y2-$y1, -4*$w, -2*$w),
		$y2 + &newy($x2-$x1, $y2-$y1, -4*$w, -2*$w)
		);

	$arrow->addPt(
		$x2 + &newx($x2-$x1, $y2-$y1, -4*$w, -$w),
		$y2 + &newy($x2-$x1, $y2-$y1, -4*$w, -$w)
		);

	$arrow->addPt(
		$x1 + &newx($x2-$x1, $y2-$y1, 0, -$w),
		$y1 + &newy($x2-$x1, $y2-$y1, 0, -$w)
		);

	if($solid){
		$map->filledPolygon($arrow,$color);
	}else{
		$map->polygon($arrow,$color);
	}

	if($linkname ne "")
	{
		print "Producing a Polygon for $linkname\n" if($DEBUG);

		my $active_html = make_html($linkname . " - " . $desc, $overlibgraphurl, $infourl);
		if($active_html ne "")
		{
			my $html = "<AREA SHAPE=\"POLY\" COORDS=\"";
			my @vertices = $arrow->vertices;
			my @points=();
			  foreach $v (@vertices)
			{
				push(@points,@$v);
			  }
			$html .= join(",",@points) . "\"";
			$html .= $active_html;
			$html .= ">\n";
			
			$allmap .= $html;
		}
	}
}


sub version {
        print <<EOM;
Network Wearthermap v$VERSION - http://netmon.grnet.gr/weathermap/
EOM
}

sub usage {
        print <<EOM;
Network Wearthermap v$VERSION - http://netmon.grnet.gr/weathermap/
Usage: $0 [OPTION]...

 -c, --config=FILE  configuration file (default $CONFIG)
 -o, --output=FILE  output image file default (default $OUTPUT)
 -v, --version      print version
 -h, --help         print this text
 -d, --debug        enable debug output
 --htmloutput=FILE  enable HTML output to FILE
 --image-uri=URI    use URI for the IMG tag when generating HTML

EOM
}
